/**
 * Minified by jsDelivr using Terser v5.37.0.
 * Original file: /npm/quill@2.0.3/blots/scroll.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{ContainerBlot,LeafBlot,Scope,ScrollBlot}from"parchment";import Delta,{AttributeMap,Op}from"quill-delta";import Emitter from"../core/emitter.js";import Block,{BlockEmbed,bubbleFormats}from"./block.js";import Break from"./break.js";import Container from"./container.js";function isLine(t){return t instanceof Block||t instanceof BlockEmbed}function isUpdatable(t){return"function"==typeof t.updateContent}class Scroll extends ScrollBlot{static blotName="scroll";static className="ql-editor";static tagName="DIV";static defaultChild=Block;static allowedChildren=[Block,BlockEmbed,Container];constructor(t,e,i){let{emitter:s}=i;super(t,e),this.emitter=s,this.batch=!1,this.optimize(),this.enable(),this.domNode.addEventListener("dragstart",(t=>this.handleDragStart(t)))}batchStart(){Array.isArray(this.batch)||(this.batch=[])}batchEnd(){if(!this.batch)return;const t=this.batch;this.batch=!1,this.update(t)}emitMount(t){this.emitter.emit(Emitter.events.SCROLL_BLOT_MOUNT,t)}emitUnmount(t){this.emitter.emit(Emitter.events.SCROLL_BLOT_UNMOUNT,t)}emitEmbedUpdate(t,e){this.emitter.emit(Emitter.events.SCROLL_EMBED_UPDATE,t,e)}deleteAt(t,e){const[i,s]=this.line(t),[n]=this.line(t+e);if(super.deleteAt(t,e),null!=n&&i!==n&&s>0){if(i instanceof BlockEmbed||n instanceof BlockEmbed)return void this.optimize();const t=n.children.head instanceof Break?null:n.children.head;i.moveChildren(n,t),i.remove()}this.optimize()}enable(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.domNode.setAttribute("contenteditable",t?"true":"false")}formatAt(t,e,i,s){super.formatAt(t,e,i,s),this.optimize()}insertAt(t,e,i){if(t>=this.length())if(null==i||null==this.scroll.query(e,Scope.BLOCK)){const t=this.scroll.create(this.statics.defaultChild.blotName);this.appendChild(t),null==i&&e.endsWith("\n")?t.insertAt(0,e.slice(0,-1),i):t.insertAt(0,e,i)}else{const t=this.scroll.create(e,i);this.appendChild(t)}else super.insertAt(t,e,i);this.optimize()}insertBefore(t,e){if(t.statics.scope===Scope.INLINE_BLOT){const i=this.scroll.create(this.statics.defaultChild.blotName);i.appendChild(t),super.insertBefore(i,e)}else super.insertBefore(t,e)}insertContents(t,e){const i=this.deltaToRenderBlocks(e.concat((new Delta).insert("\n"))),s=i.pop();if(null==s)return;this.batchStart();const n=i.shift();if(n){const e="block"===n.type&&(0===n.delta.length()||!this.descendant(BlockEmbed,t)[0]&&t<this.length()),i="block"===n.type?n.delta:(new Delta).insert({[n.key]:n.value});insertInlineContents(this,t,i);const s="block"===n.type?1:0,r=t+i.length()+s;e&&this.insertAt(r-1,"\n");const l=bubbleFormats(this.line(t)[0]),o=AttributeMap.diff(l,n.attributes)||{};Object.keys(o).forEach((t=>{this.formatAt(r-1,1,t,o[t])})),t=r}let[r,l]=this.children.find(t);if(i.length&&(r&&(r=r.split(l),l=0),i.forEach((t=>{if("block"===t.type){insertInlineContents(this.createBlock(t.attributes,r||void 0),0,t.delta)}else{const e=this.create(t.key,t.value);this.insertBefore(e,r||void 0),Object.keys(t.attributes).forEach((i=>{e.format(i,t.attributes[i])}))}}))),"block"===s.type&&s.delta.length()){insertInlineContents(this,r?r.offset(r.scroll)+l:this.length(),s.delta)}this.batchEnd(),this.optimize()}isEnabled(){return"true"===this.domNode.getAttribute("contenteditable")}leaf(t){const e=this.path(t).pop();if(!e)return[null,-1];const[i,s]=e;return i instanceof LeafBlot?[i,s]:[null,-1]}line(t){return t===this.length()?this.line(t-1):this.descendant(isLine,t)}lines(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.MAX_VALUE;const i=(t,e,s)=>{let n=[],r=s;return t.children.forEachAt(e,s,((t,e,s)=>{isLine(t)?n.push(t):t instanceof ContainerBlot&&(n=n.concat(i(t,e,r))),r-=s})),n};return i(this,t,e)}optimize(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.batch||(super.optimize(t,e),t.length>0&&this.emitter.emit(Emitter.events.SCROLL_OPTIMIZE,t,e))}path(t){return super.path(t).slice(1)}remove(){}update(t){if(this.batch)return void(Array.isArray(t)&&(this.batch=this.batch.concat(t)));let e=Emitter.sources.USER;"string"==typeof t&&(e=t),Array.isArray(t)||(t=this.observer.takeRecords()),(t=t.filter((t=>{let{target:e}=t;const i=this.find(e,!0);return i&&!isUpdatable(i)}))).length>0&&this.emitter.emit(Emitter.events.SCROLL_BEFORE_UPDATE,e,t),super.update(t.concat([])),t.length>0&&this.emitter.emit(Emitter.events.SCROLL_UPDATE,e,t)}updateEmbedAt(t,e,i){const[s]=this.descendant((t=>t instanceof BlockEmbed),t);s&&s.statics.blotName===e&&isUpdatable(s)&&s.updateContent(i)}handleDragStart(t){t.preventDefault()}deltaToRenderBlocks(t){const e=[];let i=new Delta;return t.forEach((t=>{const s=t?.insert;if(s)if("string"==typeof s){const n=s.split("\n");n.slice(0,-1).forEach((s=>{i.insert(s,t.attributes),e.push({type:"block",delta:i,attributes:t.attributes??{}}),i=new Delta}));const r=n[n.length-1];r&&i.insert(r,t.attributes)}else{const n=Object.keys(s)[0];if(!n)return;this.query(n,Scope.INLINE)?i.push(t):(i.length()&&e.push({type:"block",delta:i,attributes:{}}),i=new Delta,e.push({type:"blockEmbed",key:n,value:s[n],attributes:t.attributes??{}}))}})),i.length()&&e.push({type:"block",delta:i,attributes:{}}),e}createBlock(t,e){let i;const s={};Object.entries(t).forEach((t=>{let[e,n]=t;null!=this.query(e,Scope.BLOCK&Scope.BLOT)?i=e:s[e]=n}));const n=this.create(i||this.statics.defaultChild.blotName,i?t[i]:void 0);this.insertBefore(n,e||void 0);const r=n.length();return Object.entries(s).forEach((t=>{let[e,i]=t;n.formatAt(0,r,e,i)})),n}}function insertInlineContents(t,e,i){i.reduce(((e,i)=>{const s=Op.length(i);let n=i.attributes||{};if(null!=i.insert)if("string"==typeof i.insert){const s=i.insert;t.insertAt(e,s);const[r]=t.descendant(LeafBlot,e),l=bubbleFormats(r);n=AttributeMap.diff(l,n)||{}}else if("object"==typeof i.insert){const s=Object.keys(i.insert)[0];if(null==s)return e;t.insertAt(e,s,i.insert[s]);if(null!=t.scroll.query(s,Scope.INLINE)){const[i]=t.descendant(LeafBlot,e),s=bubbleFormats(i);n=AttributeMap.diff(s,n)||{}}}return Object.keys(n).forEach((i=>{t.formatAt(e,s,i,n[i])})),e+s}),e)}export default Scroll;
//# sourceMappingURL=/sm/65516285676b5835e5594d781192e98b89260eada3ea16f0ac0c8169869a4dc4.map